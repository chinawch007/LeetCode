# LeetCode   

## 动态规划   
- **5最长回文** : 不是线性最优解递增,统计比较   
- **71最小路径和** : 你想到的是到终点的最短距离,同样也可以是到起点的最短距离
- **139单词字典拆分** : dp要n2复杂度,所以你压根就没往这想;你是想用单词表里单词的最后一个字母做索引枚举可能性,它直接枚举全部的单词起始位置,恶心
- **494加减号目标和** : 用数组索引和结果做状态,结果维度范围较大;转换背包问题,加和   
- **55跳格子** : 从头做搜索会标识很多重复位置;从尾做dp不会做重复工作
- **300最长递增子序列** : 开始时以为是砌墙,结果是替代;找规律
- **416分割数组半和** : 传统01背包是阶段,重量,价值,这里是阶段,重量,bool
- **322零钱兑换** : 完全背包;记录解决方案;若干年前犯过类似错误,二重循环倒序,因为完全背包不限次数,加了个三重循环
- **638大礼包** : 明确告诉你我就是完全背包;每种商品的数量作为状态,一维数组表示
- **221最大正方形** : 你只盯着左上角的那个正方形;3小加1
- **337强盗打劫** : 算点不算点;树形dp,递归;指针map?
- **968监控树** : 树形dp
- **312戳气球** : 区段划分dp;每段都要选择一个最后爆,他就是划分的标准
- **903DI** : 转化成子问题,枚举最后的值
- **801两数组都递增最小交换次数** : 最初看想二进制表示状态,其实只肯前边相邻的那个,分类讨论枚举
- **474取字符串限定m0n1** : 竟没有一眼看出是dp
- **368数组中选子集相互之间都能整除** : 后两个数能相互整除,有dp嫌疑
## 双指针   
- **11盛水** : 第一反应是dp,迅速确定解题方法;指针起点是首尾,同过去的认知不同;小端坐标移动   
- **76最小覆盖子串** : 关于start索引后移的问题,不止移动一次,要铭记;用总数来衡量是否已经达标;关于科学证明还是想一下的好
- **3最长无重复子串** : 最原始的滑动窗口题
- **15三数之和** : 头尾指针,和单调变化
## 找规律   
- **31下一个排列** : 断崖,后半部重排最初没想到   
- **238除了自己的乘积** : 前缀积后缀积;"区段思维"要牢记
- **73行列变0** : 2步优化,先变其他数,防止混乱;每行列首标识,不用重复变值
- **134加油站** : 前缀和
- **325和等于k的最长子数组长度** : 前缀和;hashmap就算是O1了,真搞鬼
- **739啥时候温度增加** : 刷墙;单调栈;根据题意,位置越前值越大越优先,其他的值可以不要
- **406身高重建队列** :　排序;后进插入
- **634错位排列的数目** : 直接用1的分配就找出规律了,而不是很泛化的,尝试很重要;dp
- **651 copy A** : 官方解法中内循环有规律优化,淘汰非最优
- **1151交换0把1连一起** : 问题转换,交换问题变成求和问题
- **1124排行榜** : 自创使用优先队列的任意修改某人分数,tok方法,用版本限定
- **1167棒子长度加和** : 要一眼看出加和规律
- **1198矩阵中找多行公共最小值** : 统计数字出现次数,这其实应该是立即能想到的
- **240搜索二维矩阵** : 类似于盛水,不是从常规角度做搜索;一堆其他方法
- **1182到目标颜色最短距离** : dp解法,问题转化为距某颜色左最近右最近
- **244列表中某2个单词最短距离** : 转化为2个数组值差最小,交替增大,小的加,绝对值
- **253会议室** : 堆;类似贪心,找到一个能上车的就上;官解似乎很厉害?
- **932漂亮数组** : 分治;奇偶;正常情况下怎么想到这个
- **560和为k的子数组** : 有负数;直接用map记录不同和
- **152最大子数组积** : 类似于dp,滑动窗口,需要个演进机制,这里是以某个数字为结尾的最大子数组乘积
## 位运算   
- **78全部子集** : 用数字递增的位来表示集合   
- **50pow** : 指数二进制拆解
- **29除法** : 
## 排序   
- **148** : 链表只能用归并排序
- **347前k高频** : pq是相反的,比较函数是>堆是最小堆;桶排,计数
- **1244排行榜** : 动态堆,利用节点版本
## 树   
- **116树的同层next** : 首先想到的是找规律,为什么不是bfs?
- **510中序后继节点** : 要看自己是父节点的左儿子还是右儿子
- **307区域加和update** : 线段树;从n开始排布数字,很规范
- **236最近公共祖先** : 存父指针的方法
- **652重复子树** : 二叉树的唯一编码方法;可用hash?
- **450二叉树删除节点** : 注意,这是个递归问题,因为你找到的下边替代节点不是叶子节点
- **654数组最大值是根节点** : 沿着最右边的路径找到合适的插入位置,我当时能想到这个方法也是挺厉害的
## 搜索
- **127单词接龙** : 关于字典中单词间建边的预处理,你是想枚举每两个单词n2,其实只要自己变换字母就可以了;用map建图;双向bfs;需要两个栈,一个栈没法处理重复遇到某节点,是从那边开始搜索;用*做间接点，再连成图，高明
- **207课程表** : dfs实现拓扑排序;队列;mapvector表示图
- **39组合总数** : 一个数字一次dfs调用;排序,加了大数超标剪支;按特定顺序搜索防重复;其实也可以用dp,累加方法数
- **294翻+-** :　博弈;记忆化搜索,直接拿串当状态记录,不要只想用bit,牛逼!!!;交替搜索,先手单步有一条路径赢就行,后手双步要全赢
- **1055用子序列拼目标串** : 一个字符一个dfs调用;标度用源串次数,源串字符位置,目标串字符位置
- **1062最长重复子串** : 开始时想的是类似于后缀dp的思路,这想法其实很挠头,从相同字符位置出发的多个串,比较关系没法用一个状态标识,要二维;枚举长度,牢记
- **698划分数组每份和相同** : leetcode里能拿得出手的搜索了;从大搜到小;还有其他的剪枝感觉?
## 二分
- **33搜索旋转数组** : 二分模式,while条件>,m+-1,循环后检查se
- **287寻找重复数** : 非传统二分,目标值是二分得来,具体过程自由确定
## 并查集
- **1101最早都相识时间** : 初始化自己连自己;固定写法,i!=u[i],u[i]=u[u[i]]
- **1135最小生成树** : 用并查集判断加某边后节点是否因此连通